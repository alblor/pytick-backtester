"""
Trading Strategy Interface for backtesting.
Provides base classes and templates for implementing trading strategies.
"""

from abc import ABC, abstractmethod
from typing import Dict, List, Optional, Any, Callable
from datetime import datetime, timedelta
from dataclasses import dataclass
import logging

from core.data_structures import (
    Tick, Order, OrderType, OrderSide, Position, Trade, BacktestConfig
)


logger = logging.getLogger(__name__)


@dataclass
class StrategyConfig:
    """Configuration for trading strategies."""
    name: str
    description: str
    parameters: Dict[str, Any]
    risk_management: Dict[str, Any]
    
    def __post_init__(self):
        """Validate strategy configuration."""
        if not self.name:
            raise ValueError("Strategy name is required")
        
        # Set default risk management parameters
        if not self.risk_management:
            self.risk_management = {
                'max_position_size': 1.0,
                'stop_loss_pips': 50,
                'take_profit_pips': 100,
                'max_daily_loss': 1000,
                'max_drawdown': 0.1
            }


@dataclass
class StrategySignal:
    """Trading signal generated by a strategy."""
    timestamp: datetime
    symbol: str
    signal_type: str  # 'BUY', 'SELL', 'CLOSE', 'MODIFY'
    strength: float  # Signal strength (0.0 to 1.0)
    price: Optional[float] = None
    quantity: Optional[float] = None
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    metadata: Dict[str, Any] = None
    
    def __post_init__(self):
        if self.metadata is None:
            self.metadata = {}


@dataclass
class StrategyState:
    """Internal state of a trading strategy."""
    last_update: datetime
    indicators: Dict[str, Any]
    signals: List[StrategySignal]
    positions: Dict[str, Position]
    performance: Dict[str, float]
    
    def __post_init__(self):
        if not self.indicators:
            self.indicators = {}
        if not self.signals:
            self.signals = []
        if not self.positions:
            self.positions = {}
        if not self.performance:
            self.performance = {}


class TradingStrategy(ABC):
    """
    Abstract base class for all trading strategies.
    Provides a standardized interface for strategy development.
    """
    
    def __init__(self, config: StrategyConfig, backtest_config: BacktestConfig):
        """
        Initialize the trading strategy.
        
        Args:
            config: Strategy configuration
            backtest_config: Backtesting configuration
        """
        self.config = config
        self.backtest_config = backtest_config
        self.state = StrategyState(
            last_update=datetime.now(),
            indicators={},
            signals=[],
            positions={},
            performance={}
        )
        
        # Historical data storage
        self.price_history: Dict[str, List[Tick]] = {}
        self.max_history_length = 10000  # Maximum ticks to keep in memory
        
        # Strategy callbacks
        self.on_signal_generated: Optional[Callable[[StrategySignal], None]] = None
        self.on_position_opened: Optional[Callable[[Position], None]] = None
        self.on_position_closed: Optional[Callable[[Position, Trade], None]] = None
        
        # Performance tracking
        self.total_signals = 0
        self.winning_signals = 0
        self.losing_signals = 0
        
        logger.info(f"Initialized strategy: {self.config.name}")
    
    @abstractmethod
    def initialize(self) -> None:
        """
        Initialize the strategy.
        Called once before backtesting starts.
        """
        pass
    
    @abstractmethod
    def on_tick(self, tick: Tick) -> List[StrategySignal]:
        """
        Process a new tick and generate trading signals.
        
        Args:
            tick: New market tick
            
        Returns:
            List of trading signals
        """
        pass
    
    @abstractmethod
    def on_order_filled(self, order: Order) -> None:
        """
        Handle order fill events.
        
        Args:
            order: Filled order
        """
        pass
    
    @abstractmethod
    def on_position_update(self, position: Position) -> None:
        """
        Handle position updates.
        
        Args:
            position: Updated position
        """
        pass
    
    def finalize(self) -> None:
        """
        Finalize the strategy.
        Called once after backtesting completes.
        """
        logger.info(f"Finalizing strategy: {self.config.name}")
        logger.info(f"Total signals generated: {self.total_signals}")
        logger.info(f"Winning signals: {self.winning_signals}")
        logger.info(f"Losing signals: {self.losing_signals}")
    
    def add_tick_to_history(self, tick: Tick) -> None:
        """
        Add a tick to the price history.
        
        Args:
            tick: Tick to add to history
        """
        if tick.symbol not in self.price_history:
            self.price_history[tick.symbol] = []
        
        self.price_history[tick.symbol].append(tick)
        
        # Limit history length
        if len(self.price_history[tick.symbol]) > self.max_history_length:
            self.price_history[tick.symbol] = self.price_history[tick.symbol][-self.max_history_length:]
    
    def get_price_history(self, symbol: str, periods: int = 100) -> List[Tick]:
        """
        Get price history for a symbol.
        
        Args:
            symbol: Symbol to get history for
            periods: Number of periods to return
            
        Returns:
            List of historical ticks
        """
        if symbol not in self.price_history:
            return []
        
        return self.price_history[symbol][-periods:]
    
    def create_signal(self, tick: Tick, signal_type: str, strength: float = 1.0,
                     quantity: Optional[float] = None, stop_loss: Optional[float] = None,
                     take_profit: Optional[float] = None, **kwargs) -> StrategySignal:
        """
        Create a trading signal.
        
        Args:
            tick: Current tick
            signal_type: Type of signal ('BUY', 'SELL', 'CLOSE', 'MODIFY')
            strength: Signal strength (0.0 to 1.0)
            quantity: Position size
            stop_loss: Stop loss price
            take_profit: Take profit price
            **kwargs: Additional metadata
            
        Returns:
            Trading signal
        """
        # Apply default quantity if not specified
        if quantity is None:
            quantity = self.config.risk_management.get('max_position_size', 1.0)
        
        # Apply default stop loss if not specified
        if stop_loss is None and signal_type in ['BUY', 'SELL']:
            sl_pips = self.config.risk_management.get('stop_loss_pips', 50)
            pip_value = self._get_pip_value(tick.symbol)
            
            if signal_type == 'BUY':
                stop_loss = tick.bid - (sl_pips * pip_value)
            else:
                stop_loss = tick.ask + (sl_pips * pip_value)
        
        # Apply default take profit if not specified
        if take_profit is None and signal_type in ['BUY', 'SELL']:
            tp_pips = self.config.risk_management.get('take_profit_pips', 100)
            pip_value = self._get_pip_value(tick.symbol)
            
            if signal_type == 'BUY':
                take_profit = tick.ask + (tp_pips * pip_value)
            else:
                take_profit = tick.bid - (tp_pips * pip_value)
        
        signal = StrategySignal(
            timestamp=tick.timestamp,
            symbol=tick.symbol,
            signal_type=signal_type,
            strength=strength,
            price=tick.ask if signal_type == 'BUY' else tick.bid,
            quantity=quantity,
            stop_loss=stop_loss,
            take_profit=take_profit,
            metadata=kwargs
        )
        
        # Track signal generation
        self.total_signals += 1
        self.state.signals.append(signal)
        
        # Call callback if set
        if self.on_signal_generated:
            self.on_signal_generated(signal)
        
        return signal
    
    def _get_pip_value(self, symbol: str) -> float:
        """Get pip value for a symbol."""
        return 0.01 if 'JPY' in symbol else 0.0001
    
    def calculate_position_size(self, tick: Tick, risk_amount: float) -> float:
        """
        Calculate position size based on risk amount.
        
        Args:
            tick: Current tick
            risk_amount: Maximum risk amount
            
        Returns:
            Position size in lots
        """
        # Default implementation - can be overridden
        sl_pips = self.config.risk_management.get('stop_loss_pips', 50)
        pip_value = self._get_pip_value(tick.symbol)
        
        # Calculate position size to risk specified amount
        risk_per_pip = risk_amount / sl_pips
        position_size = risk_per_pip / (pip_value * 100000)  # Convert to lots
        
        # Apply maximum position size limit
        max_size = self.config.risk_management.get('max_position_size', 1.0)
        return min(position_size, max_size)
    
    def validate_signal(self, signal: StrategySignal) -> bool:
        """
        Validate a trading signal before execution.
        
        Args:
            signal: Signal to validate
            
        Returns:
            True if signal is valid
        """
        # Check signal strength
        if signal.strength < 0.1:
            return False
        
        # Check quantity
        if signal.quantity and signal.quantity <= 0:
            return False
        
        # Check stop loss and take profit levels
        if signal.signal_type == 'BUY':
            if signal.stop_loss and signal.stop_loss >= signal.price:
                return False
            if signal.take_profit and signal.take_profit <= signal.price:
                return False
        elif signal.signal_type == 'SELL':
            if signal.stop_loss and signal.stop_loss <= signal.price:
                return False
            if signal.take_profit and signal.take_profit >= signal.price:
                return False
        
        return True
    
    def get_performance_metrics(self) -> Dict[str, float]:
        """
        Get strategy performance metrics.
        
        Returns:
            Dictionary with performance metrics
        """
        win_rate = self.winning_signals / self.total_signals if self.total_signals > 0 else 0
        
        return {
            'total_signals': self.total_signals,
            'winning_signals': self.winning_signals,
            'losing_signals': self.losing_signals,
            'win_rate': win_rate,
            'signal_accuracy': win_rate,
            **self.state.performance
        }
    
    def reset(self) -> None:
        """Reset strategy state."""
        self.state = StrategyState(
            last_update=datetime.now(),
            indicators={},
            signals=[],
            positions={},
            performance={}
        )
        
        self.price_history.clear()
        self.total_signals = 0
        self.winning_signals = 0
        self.losing_signals = 0
        
        logger.info(f"Strategy reset: {self.config.name}")


class TechnicalIndicator(ABC):
    """Base class for technical indicators."""
    
    def __init__(self, period: int = 14):
        self.period = period
        self.values: List[float] = []
        self.is_ready = False
    
    @abstractmethod
    def calculate(self, price: float) -> Optional[float]:
        """Calculate indicator value."""
        pass
    
    def update(self, price: float) -> Optional[float]:
        """Update indicator with new price."""
        return self.calculate(price)
    
    def get_value(self) -> Optional[float]:
        """Get current indicator value."""
        return self.values[-1] if self.values else None
    
    def get_history(self, periods: int = 10) -> List[float]:
        """Get indicator history."""
        return self.values[-periods:] if self.values else []


class MovingAverage(TechnicalIndicator):
    """Simple Moving Average indicator."""
    
    def __init__(self, period: int = 14):
        super().__init__(period)
        self.price_buffer: List[float] = []
    
    def calculate(self, price: float) -> Optional[float]:
        """Calculate moving average."""
        self.price_buffer.append(price)
        
        if len(self.price_buffer) > self.period:
            self.price_buffer.pop(0)
        
        if len(self.price_buffer) == self.period:
            self.is_ready = True
            value = sum(self.price_buffer) / self.period
            self.values.append(value)
            return value
        
        return None


class RSI(TechnicalIndicator):
    """Relative Strength Index indicator."""
    
    def __init__(self, period: int = 14):
        super().__init__(period)
        self.price_buffer: List[float] = []
        self.gains: List[float] = []
        self.losses: List[float] = []
    
    def calculate(self, price: float) -> Optional[float]:
        """Calculate RSI."""
        if self.price_buffer:
            change = price - self.price_buffer[-1]
            self.gains.append(max(change, 0))
            self.losses.append(max(-change, 0))
        
        self.price_buffer.append(price)
        
        if len(self.gains) > self.period:
            self.gains.pop(0)
            self.losses.pop(0)
        
        if len(self.gains) == self.period:
            self.is_ready = True
            avg_gain = sum(self.gains) / self.period
            avg_loss = sum(self.losses) / self.period
            
            if avg_loss == 0:
                rsi = 100
            else:
                rs = avg_gain / avg_loss
                rsi = 100 - (100 / (1 + rs))
            
            self.values.append(rsi)
            return rsi
        
        return None